import { isFunction, isNullOrUndef } from 'inferno-shared';
import { options } from '../../core/options';
import { EMPTY_OBJ } from '../utils';

export function isCheckedType(type) {
	return type === 'checkbox' || type === 'radio';
}

const C = options.component;

function onTextInputChange(e) {
	C.rendering = true;
	const vNode = this.vNode;
	const props = vNode.props || EMPTY_OBJ;
	const dom = vNode.dom;
	const previousValue = props.value;

	if (props.onInput) {
		const event = props.onInput;

		if (event.event) {
			event.event(event.data, e);
		} else {
			event(e);
		}
	} else if (props.oninput) {
		props.oninput(e);
	}

	// the user may have updated the vNode from the above onInput events syncronously
	// so we need to get it from the context of `this` again
	const newVNode = this.vNode;
	const newProps = newVNode.props || EMPTY_OBJ;

	// If render is going async there is no value change yet, it will come back to process input soon
	if (previousValue !== newProps.value) {
		// When this happens we need to store current cursor position and restore it, to avoid jumping

		applyValue(newProps, dom);
	}
	if (isFunction(C.flush)) {
		C.flush();
	}
	C.rendering = false;
}

function wrappedOnChange(e) {
	C.rendering = true;
	const props = this.vNode.props || EMPTY_OBJ;
	const event = props.onChange;

	if (event.event) {
		event.event(event.data, e);
	} else {
		event(e);
	}
	if (isFunction(C.flush)) {
		C.flush();
	}
	C.rendering = false;
}

function onCheckboxChange(e) {
	C.rendering = true;
	e.stopPropagation(); // This click should not propagate its for internal use
	const vNode = this.vNode;
	const props = vNode.props || EMPTY_OBJ;
	const dom = vNode.dom;

	if (props.onClick) {
		const event = props.onClick;

		if (event.event) {
			event.event(event.data, e);
		} else {
			event(e);
		}
	} else if (props.onclick) {
		props.onclick(e);
	}

	// the user may have updated the vNode from the above onInput events syncronously
	// so we need to get it from the context of `this` again
	const newVNode = this.vNode;
	const newProps = newVNode.props || EMPTY_OBJ;

	// If render is going async there is no value change yet, it will come back to process input soon
	applyValue(newProps, dom);
	if (isFunction(C.flush)) {
		C.flush();
	}
	C.rendering = false;
}

export function processInput(vNode, dom, nextPropsOrEmpty, mounting: boolean, isControlled): void {
	applyValue(nextPropsOrEmpty, dom);
	if (isControlled) {
		dom.vNode = vNode; // TODO: Remove this when implementing Fiber's

		if (mounting) {
			if (isCheckedType(nextPropsOrEmpty.type)) {
				dom.onclick = onCheckboxChange;
				dom.onclick.wrapped = true;
			} else {
				dom.oninput = onTextInputChange;
				dom.oninput.wrapped = true;
			}
			if (nextPropsOrEmpty.onChange) {
				dom.onchange = wrappedOnChange;
				dom.onchange.wrapped = true;
			}
		}
	}
}

export function applyValue(nextPropsOrEmpty, dom) {
	const type = nextPropsOrEmpty.type;
	const value = nextPropsOrEmpty.value;
	const checked = nextPropsOrEmpty.checked;
	const multiple = nextPropsOrEmpty.multiple;
	const defaultValue = nextPropsOrEmpty.defaultValue;
	const hasValue = !isNullOrUndef(value);

	if (type && type !== dom.type) {
		dom.setAttribute('type', type);
	}
	if (multiple && multiple !== dom.multiple) {
		dom.multiple = multiple;
	}
	if (!isNullOrUndef(defaultValue) && !hasValue) {
		dom.defaultValue = defaultValue + '';
	}
	if (isCheckedType(type)) {
		if (hasValue) {
			dom.value = value;
		}
		if (!isNullOrUndef(checked)) {
			dom.checked = checked;
		}
	} else {
		if (hasValue && dom.value !== value) {
			dom.defaultValue = value;
			dom.value = value;
		} else if (!isNullOrUndef(checked)) {
			dom.checked = checked;
		}
	}
}
